#include "Table.h"

template<typename Key, typename Value>
class RBTree : public Table<Key, Value>
{
    typedef typename Table<Key, Value>::Record Record;
protected:
    enum COLOR
    {
        RED,
        BLACK
    }

    struct Node
    {
        Node* left;
        Node* right;
        COLOR color;
    }

    //у каждой вершины 2 потомка
    //чтобы этого добиться делаем фиктивных потомков у значащих вершин без потомков
    //по умолчанию все фиктивные листья являются черными
    //корень изначально черный (всегда черный)
    //у любой красной вершины оба потомка черные 
    //у черной любые потомки 
    //любой путь до фиктивныз вершин долден содержать одинаковое количество черных узлов
    //данное условие выполняется для всех узлов
    
    //при вставке верщина красится в красный цвет

    //случаи вставки
    // 1) корень - сразу меняем на черный
    // 2) добавляем к красной вершине красного потомка
    // 3) у добавленной вершины предок черный - все в норме 
    //        (красная вершина не изменила число черных вершин от корня)
    // 4) 

    // пример дерева
    //              [13]
    //              /  \
    //          (8)     (17)
    //         /  \       |   \
    //       [1]  [11]    []  [23]
    //      /  |
    //    [n]  (6)
    //


    //случай балансировки вставка красной к красной, симметричная вершина тоже красная 
    //              [13]
    //              /  \
    //          (8)     (17)
    //         /  |     /  \
    //     (ins) [..] [..]  [..]
    // замещаем 
    //              (13)
    //              /  \
    //          [8]     [17]
    //         /  |     /  \
    //     (ins) [..] [..]  [..]

    // случай с другой стороны
    //              [13]
    //              /  \
    //          (8)     (17)
    //         /  |     /  \
    //     [..]  (..) [..]  [..]
    // сводим к предыдущему случаю
    //              [13]
    //              /  \
    //          (ins)   (17)
    //         /  |     /  \
    //       (8)  [..] [..]  [..]
    //      /  \
    //    [..]  [..]
    // перекрашиваем
    //              (13)
    //              /  \
    //          [ins]   [17]
    //         /  |     /  \
    //       (8)  [..] [..]  [..]
    //      /  \
    //    [..]  [..]
    // либо просто сделать симметричный метод (так проще)

    // случай вставки 2 (балансировки)
    //              [13]
    //              /  \
    //          (8)     [17]
    //         /  |     /  \
    //     (ins) [x] [y]  [z]
    // решение ll shift как на авл
    //              [8]
    //              /  \
    //          (ins)   (13)
    //         /  |     /  \
    //       [n] [n]  [x]  [17]
    //                     /   \
    //                   [y]    [z]


    //удаление 
    // удаление с двумя потомками как в авл
    // удаление вершины со значимым потомком
    // удаление черной вершины с красным потомком

    //удаление узлов с разны цветом (удаляем узел ставим потомка меняем цвет)
public:
}